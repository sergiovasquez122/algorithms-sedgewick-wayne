4.1.1 What is the maximum number of edges in a graph with V vertices and no parallel edges?
What is the minimum number of edges in a graph with V vertices, none of which are isolated?
V * (V-1) / 2 and V - 1

4.1.2 Draw, in the style of the figure in the text, the adjacency lists built by Graph's input
stream constructor for the files tinyGex2.txt

0 -> [6, 2, 5]
1 -> [11, 4, 8]
2 -> [0, 6, 3, 5]
3 -> [10, 2, 6]
4 -> [8, 1]
5 -> [0, 2, 10]
6 -> [0, 2, 3]
7 -> [8, 11]
8 -> [4, 7, 11, 1]
9 -> []
10 ->  [5, 3]
11 -> [8, 7, 1]

4.1.6 Consider the four-vertex graph with edges 0-1, 1-2, 2-3, and 3-0. Drawn an array of adjacency-list that could not
have been built calling addEdge() for these edges no matter what order.
0 -> [1, 3]
1 -> [2, 0]
2 -> [3, 1]
3 -> [0, 2]

4.1.12 what does the BFS tree tell us about the distance from v to w when neither is at the root?

If both of the vertices are on different branches then it tells use there is path
of length distTo[v] + distTo[w] to get from u to v. where the distTo array tells the
distance of a vertex to the root. if they are on the same brance then the
distance from v to w is the abs(dist[v] - dist[w]).

4.1.14 Suppose you use a stack instead of a queue when running breadth-first search. Does it still compute shortest paths.

No we show this with a counter-example. Suppose the undirected
graph given below.

1 - 2
 \ /
  0 (source)

A breadth-first search would produce distances of integer value 1
for both vertices 1 and 2. A dfs solution would produce one vertex of
distance 1 and another of distance 2. This shows that dfs is not guaranteed to compute
the shortest path in a graph.

4.1.9 Show, in the style of figure on page 533, a detailed trace of the call dfs(0) for the
the graph built by the Graph's input stream constructor for the file tinyGex2.txt.
Also, draw the tree represented by edgeTo[].

1st iteration
marked[]  adj[]
0 | T     0 | 5 2 6
1 |       1 | 4 8 11
2 |       2 | 5 6 0 3
3 |       3 | 10 6 2
4 |       4 | 1 8
5 |       5 | 0 10 2
6 |       6 | 2 3 0
7 |       7 | 8 11
8 |       8 | 1 11 7 4
9 |       9 |
10|       10| 5 3
11|       11|8 7 1

2nd iteration
marked[]  adj[]
0 | T     0 | 5 2 6
1 |       1 | 4 8 11
2 |       2 | 5 6 0 3
3 |       3 | 10 6 2
4 |       4 | 1 8
5 |T      5 | 0 10 2
6 |       6 | 2 3 0
7 |       7 | 8 11
8 |       8 | 1 11 7 4
9 |       9 |
10|       10| 5 3
11|       11|8 7 1

3rd iteration
marked[]  adj[]
0 | T     0 | 5 2 6
1 |       1 | 4 8 11
2 |       2 | 5 6 0 3
3 |       3 | 10 6 2
4 |       4 | 1 8
5 |T      5 | 0 10 2
6 |       6 | 2 3 0
7 |       7 | 8 11
8 |       8 | 1 11 7 4
9 |       9 |
10|T      10| 5 3
11|       11|8 7 1

4th iteration
marked[]  adj[]
0 | T     0 | 5 2 6
1 |       1 | 4 8 11
2 |       2 | 5 6 0 3
3 |T      3 | 10 6 2
4 |       4 | 1 8
5 |T      5 | 0 10 2
6 |       6 | 2 3 0
7 |       7 | 8 11
8 |       8 | 1 11 7 4
9 |       9 |
10|T      10| 5 3
11|       11|8 7 1

5th iteration
marked[]  adj[]
0 | T     0 | 5 2 6
1 |       1 | 4 8 11
2 |       2 | 5 6 0 3
3 |T      3 | 10 6 2
4 |       4 | 1 8
5 |T      5 | 0 10 2
6 |T       6 | 2 3 0
7 |       7 | 8 11
8 |       8 | 1 11 7 4
9 |       9 |
10|T      10| 5 3
11|       11|8 7 1

6th iteration
marked[]  adj[]
0 | T     0 | 5 2 6
1 |       1 | 4 8 11
2 |T       2 | 5 6 0 3
3 |T      3 | 10 6 2
4 |       4 | 1 8
5 |T      5 | 0 10 2
6 |T       6 | 2 3 0
7 |       7 | 8 11
8 |       8 | 1 11 7 4
9 |       9 |
10|T      10| 5 3
11|       11|8 7 1

the tree represented by edgeTo[]
           0
          /
         5
        /
       10
      /
     3
    /
   6
  /
 2


4.1.11 Draw the tree represented by edgeTo[] after the call bfs(G, 0) in
algorithm 4.2 for the graph by Graph's input stream constructor for the file tinyGex2.txt

    0
   /|\
  5  2  6
 /   /
10   3

4.1.12 Prove that every connected graph has a vertex who removal
will not disconnect the graph, and write a graph a dfs method that
finds such a vertex.

trying the proof using induction
We prove this by strong induction. Let P(n) be that any connected graph with n vertices
has at least two vertices such that the their removal would not disconnect the graph where n>=2
The base case P(2) holds.
Assume it holds for P(2), ... , P(n), we show then that is must also hold for P(n + 1).
Let G be a graph with n + 1 vertices. Suppose that the graph has no
vertex such that it removal would disconnect the graph, then we're done.
else suppose that there is a vertex v that separate the graph in two at least two
connected components G1 and G2. WLOG suppose G1 has only one vertex then
it had degree one in the original graph G and hence could be removed without
disconnecting the graph G. else if G1 has more than one vertex
then by IHOP it has at least two edges u1 and u2 such that their removal
would not disconnect the graph. if any those two edges do not disconnect G then we're done.
suppose that u1 disconnect G then it must be the only neighbor of v or
else v would disconnect G1 - u1 to the rest of the graph. so u2 doesn't connect G as v
is connected to G1 - u2 through u1. A similar argument can be used to G2. hence we conclude Graph with
at least 2 vertices must have at least two vertices that do not disconnect the
graph.

trying the proof more alongside an algorithm

Since the graph is connected there is a path from
every vertex to every other vertex. we construct a labeling ordering of
v1,v2 .. vn. WLOG We compute the dfs tree rooted at vertex v1. the dfs tree must contain
every vertex in the graph since the graph is connected. We note then that any leaf in the tree would
be a candidate for removal in the graph G. to see this we note that ny leaf node has the property
that every vertex adjacent to it has already been visited since if it hadn't the current vertex would not have
been a leaf node. removing this vertex alongside all of its edges would not disconnect the graph.

4.1.19 Show, in the style of the figure on page 545, a detailed trace of cc for finding the
connected components in the graph built by Graph's input stream constructor for the file
tinyGex2.txt

         count            marked[]                       id[]
                           0 1 2 3 4 5 6 7 8 9 10 11    0 1 2 3 4 5 6 7 8 9 10 11
dfs(0)               0     T                            0
 dfs(5)              0     T         T                  0         0
  check 0
  dfs(10)            0     T         T         T        0         0         0
   check 5
   dfs(3)            0     T     T   T         T        0     0   0         0
    check 10
    dfs(6)           0     T     T   T T       T        0     0   0 0       0
     dfs(2)          0     T   T T   T T       T        0   0 0   0 0       0
      check 5
      check 6
      check 0
      check 3
     2 done
     check 3
     check 0
    6 done
    check 2
   3 done
  10 done
  check 2
 5 done
 check 2
 check 6
0 done
dfs(1)               1     T T T T   T T       T        0 1 0 0   0 0       0
 dfs(4)              1     T T T T T T T       T        0 1 0 0 1 0 0       0
  check 1
  dfs(8)             1     T T T T T T T   T   T        0 1 0 0 1 0 0   1   0
   check 1
   dfs(11)           1     T T T T T T T   T   T  T     0 1 0 0 1 0 0   1   0  1
    check 8
    dfs(7)           1     T T T T T T T T T   T  T     0 1 0 0 1 0 0 1 1   0  1
     check 8
     check 11
    7 done
    check 1
   11 done
   check 7
   check 4
  8 done
 4 done
 check 8
 check 11
1 done
dfs(9)               2     T T T T T T T T T T T  T     0 1 0 0 1 0 0 1 1 2 0  1
9 done

4.1.20 Show, in the style of the figures in this section, a detailed trace of Cycle for finding cycle in the graph built by Graph's input stream constructor
for finding a cycle in the graph built by Graph's input stream constructor for the file
tinyGex2.txt. What is the order of growth of the running time of the cycle constructor in the worst case?

         Has Cycle?             marked[]
                  F        0 1 2 3 4 5 6 7 8 9 10 11
dfs(0)                     T
 dfs(5)                    T         T
  check 0         F
  dfs(10)                  T         T         T
   check 5        F
   dfs(3)                  T     T   T         T
    check 10      F
    dfs(6)                 T     T   T T       T
     dfs(2)                T   T T   T T       T
      check 5     T (cycle found here)
      check 6     T
      check 0     T
      check 3     T
     2 done
     check 3      T
     check 0      T
    6 done
    check 2       T
   3 done
  10 done
  check 2         T
 5 done
 check 2          T
 check 6          T
0 done
dfs(1)                     T T T T   T T       T
 dfs(4)                    T T T T T T T       T
  check 1         T
  dfs(8)                   T T T T T T T   T   T
   check 1        T
   dfs(11)                 T T T T T T T   T   T  T
    check 8       T
    dfs(7)                 T T T T T T T T T   T  T
     check 8      T
     check 11     T
    7 done
    check 1       T
   11 done
   check 7        T
   check 4        T
  8 done
 4 done
 check 8          T
 check 11         T
1 done
dfs(9)                     T T T T T T T T T T T  T
9 done

the order of growth is O(|V| + |E|) since it uses dfs as its main routine.

4.1.21 Show, in the style of the figures in this section, a detailed trace fo TwoColor for finding
a two-coloring of the graph built by Graph's input stream constructor for the file tinyGex2.txt. What is the order of growth
of the running time of the TwoColor constructor, in the worst case?

             Is 2-colorable?                marked[]                     color[]
                     T               0 1 2 3 4 5 6 7 8 9 10 11    0 1 2 3 4 5 6 7 8 9 10 11
dfs(0)                               T                            F F F F F F F F F F F  F
 dfs(5)                              T         T                  F F F F F T F F F F F  F
  check 0            T
  dfs(10)                            T         T         T        F F F F F T F F F F F  F
   check 5           T
   dfs(3)                            T     T   T         T        F F F T F T F F F F F  F
    check 10         T
    dfs(6)                           T     T   T T       T        F F F T F T F F F F F  F
     dfs(2)                          T   T T   T T       T        F F T T F T F F F F F  F
      check 5        F
      check 6        F
      check 0        F
      check 3        F
     2 done
     check 3         F
     check 0         F
    6 done
    check 2          F
   3 done
  10 done
  check 2            F
 5 done
 check 2             F
 check 6             F
0 done
dfs(1)                               T T T T   T T       T        F F T T F T F F F F F  F
 dfs(4)                              T T T T T T T       T        F F T T T T F F F F F  F
  check 1            F
  dfs(8)                             T T T T T T T   T   T        F F T T F T F F F F F  F
   check 1           F
   dfs(11)                           T T T T T T T   T   T  T     F F T T F T F F F F F  T
    check 8          F
    dfs(7)                           T T T T T T T T T   T  T     F F T T F T F F F F F  F
     check 8         F
     check 11        F
    7 done
    check 1          F
   11 done
   check 7           F
   check 4           F
  8 done
 4 done
 check 8             F
 check 11            F
1 done
dfs(9)                               T T T T T T T T T T T  T     F F T T F T F F F F F  F
9 done


the order of grow is O(|V| + |E|) since it uses dfs as its main routine.

4.1.22 Run SymbolGraph with movies.txt to find the Kevin Bacon Number of this year's
Oscars nominees

4.1.23 Write a program BaconHistogram that prints a histogram of Kevin Bacon numbers, indicating how many performers from movies.txt
have a Bacon number of 0, 1, 2, 3 ... . Include a category for those who have an infinite number.

4.1.24 Compute the number the of connected components in movies.txt the size of the largest component and teh number of components
of size less than 10. Find the eccentricity, diameter, radius, a center, and girth of the largest component in the graph.
Does it contain keving bacon?

4.1.25 Modify DegreeOfSeparation to tak an int value y as a command-line argument and ignore moves that are more than y years old

4.1.26 Write a SymbolGraph client like DegreesOfSeparation that uses depth-first-search instead
of breath-first search to find paths connecting two performers.
